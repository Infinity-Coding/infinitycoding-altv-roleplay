"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = parserArgs;
var _commander = _interopRequireDefault(require("commander"));
var _core = require("@swc/core");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const pkg = require("../../package.json");
_commander.default.option("-f, --filename [filename]", "filename to use when reading from stdin - this will be used in source-maps, errors etc");
_commander.default.option("--config-file [path]", "Path to a .swcrc file to use");
_commander.default.option("--env-name [name]", "The name of the 'env' to use when loading configs and plugins. " + "Defaults to the value of SWC_ENV, or else NODE_ENV, or else 'development'.");
_commander.default.option("--no-swcrc", "Whether or not to look up .swcrc files");
_commander.default.option("--delete-dir-on-start", "Whether or not delete output directory on start");
_commander.default.option("--ignore [list]", "list of glob paths to **not** compile", collect);
_commander.default.option("--only [list]", "list of glob paths to **only** compile", collect);
_commander.default.option("-w, --watch", "Recompile files on changes");
_commander.default.option("-q, --quiet", "Suppress compilation output");
_commander.default.option("-s, --source-maps [true|false|inline|both]", "generate source maps", unstringify);
_commander.default.option("--source-map-target [string]", "set `file` on returned source map");
_commander.default.option("--source-file-name [string]", "set `sources[0]` on returned source map");
_commander.default.option("--source-root [filename]", "the root from which all sources are relative");
_commander.default.option("-o, --out-file [out]", "Compile all input files into a single file");
_commander.default.option("-d, --out-dir [out]", "Compile an input directory of modules into an output directory");
_commander.default.option("-D, --copy-files", "When compiling a directory copy over non-compilable files");
_commander.default.option("--include-dotfiles", "Include dotfiles when compiling and copying non-compilable files");
_commander.default.option("-C, --config <config>", "Override a config from .swcrc file. e.g. -C module.type=amd -C module.moduleId=hello", collect);
_commander.default.option("--sync", "Invoke swc synchronously. Useful for debugging.", collect);
_commander.default.option("--log-watch-compilation", "Log a message when a watched file is successfully compiled", true);
_commander.default.option("--extensions [list]", "Use specific extensions", collect);
_commander.default.version(`\n@swc/cli: ${pkg.version}\n@swc/core: ${_core.version}\n`);
_commander.default.usage("[options] <files ...>");
function unstringify(val) {
    try {
        return JSON.parse(val);
    } catch  {
        return val;
    }
}
function collect(value, previousValue) {
    // If the user passed the option with no value, like "babel file.js --presets", do nothing.
    if (typeof value !== "string") return previousValue;
    const values = value.split(",");
    return previousValue ? previousValue.concat(values) : values;
}
function parserArgs(args) {
    _commander.default.parse(args);
    const opts = _commander.default.opts();
    const filenames = _commander.default.args;
    const errors = [];
    if (opts.outDir && !filenames.length) {
        errors.push("--out-dir requires filenames");
    }
    if (opts.outFile && opts.outDir) {
        errors.push("--out-file and --out-dir cannot be used together");
    }
    if (opts.watch) {
        if (!opts.outFile && !opts.outDir) {
            errors.push("--watch requires --out-file or --out-dir");
        }
        if (!filenames.length) {
            errors.push("--watch requires filenames");
        }
    }
    if (!opts.outDir && filenames.length === 0 && typeof opts.filename !== "string" && opts.swcrc !== false) {
        errors.push("stdin compilation requires either -f/--filename [filename] or --no-swcrc");
    }
    if (errors.length) {
        console.error("swc:");
        for (const error of errors){
            console.error("  " + error);
        }
        process.exit(2);
    }
    const swcOptions = {
        jsc: {
            parser: undefined,
            transform: {
            }
        },
        // filename,
        sourceMaps: opts.sourceMaps,
        sourceFileName: opts.sourceFileName,
        sourceRoot: opts.sourceRoot,
        configFile: opts.configFile
    };
    if (opts.config) {
        for (const cfg of opts.config){
            const i = cfg.indexOf("=");
            let key;
            let value;
            if (i === -1) {
                key = cfg;
                value = true;
            } else {
                key = cfg.substring(0, i);
                value = unstringify(cfg.substring(i + 1));
            }
            //@ts-expect-error
            swcOptions[key] = value;
        }
    }
    const cliOptions = {
        outDir: opts.outDir,
        outFile: opts.outFile,
        filename: opts.filename,
        filenames,
        sync: !!opts.sync,
        sourceMapTarget: opts.sourceMapTarget,
        extensions: opts.extensions || _core.DEFAULT_EXTENSIONS,
        watch: !!opts.watch,
        copyFiles: !!opts.copyFiles,
        includeDotfiles: !!opts.includeDotfiles,
        deleteDirOnStart: Boolean(opts.deleteDirOnStart),
        quiet: !!opts.quiet
    };
    return {
        swcOptions,
        cliOptions
    };
}
